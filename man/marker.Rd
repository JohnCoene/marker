% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/class.R
\name{marker}
\alias{marker}
\title{Marker}
\description{
Highlight text in shiny.
}
\details{
Initialise a marker object to point at a CSS 
\code{selector} then use methods to \code{mark} or 
\code{unmark} text.
}
\examples{
library(shiny)

# load a paragraph
data(lorem, package = "marker")

ui <- fluidPage(
  useMarker(),
  p(id = "text-to-mark", lorem),
  textInput("mark", "Text to mark")
)

server <- function(input, output){

  my_marker <- marker$new("#text-to-mark")

  observeEvent(input$mark, {
    my_marker$
      unmark()$ # unmark previously marked text
      mark(input$mark) # mark what is searched
  })

}

if(interactive())
  shinyApp(ui, server)


## ------------------------------------------------
## Method `marker$new`
## ------------------------------------------------

library(shiny)

# load a paragraph
data(lorem, package = "marker")

ui <- fluidPage(
  useMarker(),
  p(id = "text-to-mark", lorem),
  textInput("mark", "Text to mark")
)

server <- function(input, output){

  my_marker <- marker$new("#text-to-mark")

  observeEvent(input$mark, {
    my_marker$
      unmark()$ # unmark previously marked text
      mark(input$mark) # mark what is searched
  })

}

if(interactive())
  shinyApp(ui, server)

## ------------------------------------------------
## Method `marker$mark`
## ------------------------------------------------

library(shiny)

# load a paragraph
data(lorem, package = "marker")

ui <- fluidPage(
  useMarker(),
  p(id = "text-to-mark", lorem),
  actionButton("mark", "Mark lorem")
)

server <- function(input, output){

  my_marker <- marker$new("#text-to-mark")

  observeEvent(input$mark, {
    my_marker$
      unmark()$ # unmark previously marked text
      mark("lorem") # mark what is searched
  })

}

if(interactive())
 shinyApp(ui, server)

## ------------------------------------------------
## Method `marker$mark_regex`
## ------------------------------------------------

library(shiny)

# load a paragraph
data(lorem, package = "marker")

ui <- fluidPage(
  useMarker(),
  p(id = "text-to-mark", lorem),
  actionButton("mark", "Mark")
)

server <- function(input, output){

  my_marker <- marker$new("#text-to-mark")

  observeEvent(input$mark, {
    my_marker$
      unmark()$ # unmark previously marked text
      mark_regex('[a-z]') # mark what is searched
  })

}

if(interactive())
  shinyApp(ui, server)

## ------------------------------------------------
## Method `marker$mark_ranges`
## ------------------------------------------------

library(shiny)

# load a paragraph
data(lorem, package = "marker")

ui <- fluidPage(
  useMarker(),
  p(id = "text-to-mark", lorem),
  actionButton("mark", "Mark")
)

server <- function(input, output){

  my_marker <- marker$new("#text-to-mark")

  observeEvent(input$mark, {
    my_marker$
      unmark()$ # unmark previously marked text
      mark_ranges(list(list(start = 5, length = 10))) # mark what is searched
  })

}

if(interactive())
  shinyApp(ui, server)

## ------------------------------------------------
## Method `marker$get_marked`
## ------------------------------------------------

library(shiny)

# load a paragraph
data(lorem, package = "marker")

ui <- fluidPage(
  useMarker(),
  p(id = "text-to-mark", lorem),
  actionButton("mark", "Mark"),
  verbatimTextOutput("marked")
)

server <- function(input, output){

  my_marker <- marker$new("#text-to-mark")

  observeEvent(input$mark, {
    my_marker$
      unmark()$
      mark_regex('[a-z]', send_marked = TRUE)
  })

  output$marked <- renderPrint({
     my_marker$get_marked() 
  })

}

if(interactive())
  shinyApp(ui, server)
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{session}}{Get or set the session, if NULL returns the previously 
assigned reactive context.}

\item{\code{name}}{Set the name to identify the marker internally. This is read-only.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{marker$new()}}
\item \href{#method-mark}{\code{marker$mark()}}
\item \href{#method-unmark}{\code{marker$unmark()}}
\item \href{#method-mark_regex}{\code{marker$mark_regex()}}
\item \href{#method-mark_ranges}{\code{marker$mark_ranges()}}
\item \href{#method-get_marked}{\code{marker$get_marked()}}
\item \href{#method-clone}{\code{marker$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{marker$new(selector, session = NULL, name = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{selector}}{A valid CSS selector, e.g.: \code{#id}, 
\code{.class}, or \code{div}.}

\item{\code{session}}{A valid shiny session, if \code{NULL} (default)
then the function attempts to get the current reacive domain.}

\item{\code{name}}{A name, useful to distinguish between markers. If
\code{NULL} a random name is generated.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Initialise a marker with \code{new} method.
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{library(shiny)

# load a paragraph
data(lorem, package = "marker")

ui <- fluidPage(
  useMarker(),
  p(id = "text-to-mark", lorem),
  textInput("mark", "Text to mark")
)

server <- function(input, output){

  my_marker <- marker$new("#text-to-mark")

  observeEvent(input$mark, {
    my_marker$
      unmark()$ # unmark previously marked text
      mark(input$mark) # mark what is searched
  })

}

if(interactive())
  shinyApp(ui, server)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-mark"></a>}}
\if{latex}{\out{\hypertarget{method-mark}{}}}
\subsection{Method \code{mark()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{marker$mark(keywords, ..., send_marked = FALSE, delay = 0)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{keywords}}{A vector or character string of keywords
to highlight.}

\item{\code{...}}{Options passed to JavaScript, see the 
\href{https://markjs.io/}{official documentation} under "mark"
for the full list.}

\item{\code{send_marked}}{Whether to send the number of highlighted 
keywords to the R server. These can then be accessed with 
the \code{get_marked} method. Note that this overwrites the 
\code{done} options passed to the three dot construct.}

\item{\code{delay}}{Delay in milliseconds before highlighting text.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
A method to highlight custom search terms.
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{library(shiny)

# load a paragraph
data(lorem, package = "marker")

ui <- fluidPage(
  useMarker(),
  p(id = "text-to-mark", lorem),
  actionButton("mark", "Mark lorem")
)

server <- function(input, output){

  my_marker <- marker$new("#text-to-mark")

  observeEvent(input$mark, {
    my_marker$
      unmark()$ # unmark previously marked text
      mark("lorem") # mark what is searched
  })

}

if(interactive())
 shinyApp(ui, server)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-unmark"></a>}}
\if{latex}{\out{\hypertarget{method-unmark}{}}}
\subsection{Method \code{unmark()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{marker$unmark(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Options passed to JavaScript, see the 
\href{https://markjs.io/}{official documentation} under "unmark"
for the full list.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
A method to remove highlights created by mark.js.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-mark_regex"></a>}}
\if{latex}{\out{\hypertarget{method-mark_regex}{}}}
\subsection{Method \code{mark_regex()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{marker$mark_regex(regex, ..., send_marked = FALSE, delay = 0)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{regex}}{A valid \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions}{regular expression}.}

\item{\code{...}}{Options passed to JavaScript, see the 
\href{https://markjs.io/}{official documentation} under "markRegExp"
for the full list.}

\item{\code{send_marked}}{Whether to send the number of highlighted 
keywords to the R server. These can then be accessed with 
the \code{get_marked} method. Note that this overwrites the 
\code{done} options passed to the three dot construct.}

\item{\code{delay}}{Delay in milliseconds before highlighting text.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
A method to highlight custom regular expressions.
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{library(shiny)

# load a paragraph
data(lorem, package = "marker")

ui <- fluidPage(
  useMarker(),
  p(id = "text-to-mark", lorem),
  actionButton("mark", "Mark")
)

server <- function(input, output){

  my_marker <- marker$new("#text-to-mark")

  observeEvent(input$mark, {
    my_marker$
      unmark()$ # unmark previously marked text
      mark_regex('[a-z]') # mark what is searched
  })

}

if(interactive())
  shinyApp(ui, server)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-mark_ranges"></a>}}
\if{latex}{\out{\hypertarget{method-mark_ranges}{}}}
\subsection{Method \code{mark_ranges()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{marker$mark_ranges(ranges, ..., send_marked = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{ranges}}{A list of ranges \code{list(list(start = 1, length = 3), list(start = 5, length = 3))}.}

\item{\code{...}}{Options passed to JavaScript, see the 
\href{https://markjs.io/}{official documentation} under "markRanges"
for the full list.}

\item{\code{send_marked}}{Whether to send the number of highlighted 
keywords to the R server. These can then be accessed with 
the \code{get_marked} method. Note that this overwrites the 
\code{done} options passed to the three dot construct.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
A method to mark ranges with a start position and length. They will be applied to text nodes in the specified context.
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{library(shiny)

# load a paragraph
data(lorem, package = "marker")

ui <- fluidPage(
  useMarker(),
  p(id = "text-to-mark", lorem),
  actionButton("mark", "Mark")
)

server <- function(input, output){

  my_marker <- marker$new("#text-to-mark")

  observeEvent(input$mark, {
    my_marker$
      unmark()$ # unmark previously marked text
      mark_ranges(list(list(start = 5, length = 10))) # mark what is searched
  })

}

if(interactive())
  shinyApp(ui, server)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_marked"></a>}}
\if{latex}{\out{\hypertarget{method-get_marked}{}}}
\subsection{Method \code{get_marked()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{marker$get_marked()}\if{html}{\out{</div>}}
}

\subsection{Details}{
A method to returned the number of keywords marked.

This requires setting \code{send_marked} to \code{TRUE} in
the various \code{mark*} functions.
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{library(shiny)

# load a paragraph
data(lorem, package = "marker")

ui <- fluidPage(
  useMarker(),
  p(id = "text-to-mark", lorem),
  actionButton("mark", "Mark"),
  verbatimTextOutput("marked")
)

server <- function(input, output){

  my_marker <- marker$new("#text-to-mark")

  observeEvent(input$mark, {
    my_marker$
      unmark()$
      mark_regex('[a-z]', send_marked = TRUE)
  })

  output$marked <- renderPrint({
     my_marker$get_marked() 
  })

}

if(interactive())
  shinyApp(ui, server)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{marker$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
